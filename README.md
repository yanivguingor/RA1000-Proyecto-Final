# RA1000-Proyecto Final

Proyecto en Python: Creación de Librerías en Google Colab

Durante este semestre, desarrollé un proyecto dividido en tres etapas principales, trabajando con Google Colab y utilizando Python como lenguaje principal. Este proyecto no solo me permitió afianzar conceptos básicos y avanzados de programación, sino que también reforzó mis habilidades en el uso de herramientas matemáticas y de programación estructurada. A continuación, detallo cada una de las tres partes que conformaron el proyecto.

Primera Librería: Creación de Objetos, Variables y Operaciones en Python
La primera etapa del proyecto consistió en diseñar una librería básica para trabajar con objetos, variables y operaciones en Python. Mi objetivo era consolidar los fundamentos de programación, creando estructuras que pudieran ser reutilizadas en cálculos posteriores.
Comencé declarando distintos tipos de variables, como números enteros, flotantes, cadenas de texto y listas. Por ejemplo, implementé operaciones matemáticas sencillas utilizando operadores aritméticos y funciones básicas como sum() y len(). También introduje conceptos de programación orientada a objetos, diseñando clases que representaban figuras geométricas como rectángulos y círculos. Para estas clases, definí atributos como el radio o los lados, y métodos para calcular áreas y perímetros.
Un aspecto interesante fue integrar el manejo de errores utilizando bloques try-except. Esto me permitió capturar errores comunes como divisiones por cero o entradas de datos no válidas, mejorando la robustez del código.
Además, añadí comentarios y documentación dentro del código para facilitar su comprensión. Esto fue esencial porque sabía que esta librería serviría como base para las siguientes etapas del proyecto. La práctica de escribir código limpio y legible fue algo que reforcé en esta etapa.

Segunda Librería: Eliminación de Gauss
La segunda parte del proyecto abordó un problema más complejo: la implementación de la eliminación de Gauss para resolver sistemas de ecuaciones lineales. Este método, ampliamente utilizado en álgebra lineal, requirió no solo la comprensión teórica de los pasos, sino también la capacidad de traducirlos en un algoritmo funcional.
Implementé la eliminación de Gauss en una función que aceptaba una matriz ampliada como entrada. Utilicé bucles anidados para aplicar las operaciones elementales de fila necesarias para convertir la matriz en su forma escalonada. Uno de los retos principales fue garantizar que el código identificara y manejara pivotes nulos, para lo cual añadí condiciones que intercambiaban filas cuando era necesario.
Una vez alcanzada la forma escalonada, desarrollé una función adicional para realizar la sustitución regresiva, obteniendo así las soluciones del sistema. Probé esta librería con diferentes matrices para validar su precisión y corregir errores. Durante este proceso, aprendí a depurar código más eficientemente y a interpretar los resultados numéricos para identificar posibles inconsistencias.
Algo que me pareció fascinante fue ver cómo un concepto matemático que parecía abstracto podía ser traducido en un conjunto de instrucciones claras para una computadora. Esta etapa me ayudó a entender la importancia de la optimización en los algoritmos, especialmente en problemas que involucran grandes cantidades de datos.

Tercera Librería: Resolución de Ecuaciones con NumPy
La última etapa del proyecto fue, sin duda, la más técnica, ya que implicó utilizar la librería NumPy para resolver sistemas de ecuaciones. Aquí, el objetivo fue comparar mi implementación manual del método de Gauss con la solución automatizada que ofrece esta librería, entendiendo sus ventajas y limitaciones.
Para resolver sistemas de ecuaciones, utilicé la función numpy.linalg.solve(), que requiere como entrada la matriz de coeficientes y el vector de términos independientes. Quedé impresionado por la eficiencia de esta función, ya que solucionaba sistemas complejos en cuestión de milisegundos. Además, exploré otras funciones de NumPy, como numpy.dot() para multiplicación de matrices y numpy.linalg.inv() para calcular inversas, aplicándolas en ejemplos prácticos.
Un punto clave en esta etapa fue la validación de resultados. Comparé las soluciones obtenidas con NumPy contra las generadas por mi propia implementación del método de Gauss, y en todos los casos, coincidieron perfectamente. Esto me dio confianza en la precisión de ambos enfoques, pero también me hizo reflexionar sobre la importancia de utilizar herramientas optimizadas en proyectos reales.
Adicionalmente, trabajé con matrices grandes para evaluar el rendimiento de NumPy en comparación con mi código manual. Observé que, aunque mi implementación funcionaba bien para matrices pequeñas, NumPy era significativamente más rápido en matrices grandes, lo que destaca la ventaja de utilizar librerías especializadas.

Reflexión Final
Este proyecto fue una experiencia enriquecedora que me permitió integrar conocimientos de programación y matemáticas aplicadas. Al dividir el trabajo en tres etapas, logré avanzar desde conceptos básicos hasta aplicaciones más avanzadas, reforzando habilidades técnicas y analíticas.
Una de las lecciones más importantes fue comprender cómo optimizar mi código y aprovechar herramientas como NumPy, que facilitan tareas complejas. También valoré la importancia de documentar cada paso y asegurar la reutilización del código, habilidades esenciales para cualquier proyecto de programación.
Finalmente, este proyecto no solo consolidó mi conocimiento teórico, sino que también me dejó preparado para abordar problemas más avanzados en el futuro. Estoy convencido de que la programación es una herramienta poderosa para resolver problemas del mundo real, y este proyecto fue un paso significativo en mi formación profesional.
